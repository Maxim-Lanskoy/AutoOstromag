//
//  üìÆ Handlers.swift
//  üë©üèº‚Äçüî¨ Auto Ostromag
//
//  Created by ‚õ©Ô∏è Karl Shinobi on 07.06.2025.
//

import TDLibKit
import Foundation

internal extension OstromagBot {
    
    static func handleStaticUpdate(data: Data, client: TDLibClient, sessionName: String, gameState: GameState) async {
        do {
            let update = try client.decoder.decode(Update.self, from: data)
            
            switch update {
            case .updateNewMessage(let newMessage):
                await self.handleStaticGameMessage(message: newMessage.message, client: client, gameState: gameState)
            default:
                break
            }
        } catch {
            print("‚ùå Error handling update: \(error)")
        }
    }
    
    static private func handleStaticGameMessage(message: Message, client: TDLibClient, gameState: GameState) async {
        guard let chat = try? await client.getChat(chatId: message.chatId) else {
            return
        }
                
        // Only process messages from the game channel, not from reporting channel
        guard chat.id == ostromagId else {
            return
        }
        
        guard case .messageText(let textContent) = message.content else {
            return
        }
        
        let text = textContent.text.text
        print("üì® Game message: \(text)")
        
        await self.process(text: text, client: client, chatId: message.chatId, gameState: gameState)
    }
    
    static private func process(text: String, client: TDLibClient, chatId: Int64, gameState: GameState) async {
        
        // Check for bot control commands
        if text.hasPrefix("/") {
            await handleCommand(text, client: client, chatId: chatId, gameState: gameState)
            return
        }
        
        // Only process game messages if bot is running
        guard await gameState.isRunning() else { return }
        
        // Update stats if character info message
        if text.contains("‚öîÔ∏è") && text.contains("–†—ñ–≤–µ–Ω—å") && text.contains("‚ù§Ô∏è –ó–¥–æ—Ä–æ–≤'—è:") {
            await gameState.updateFromCharacterInfo(text)
            print("üìä Updated player stats")
        }
        
        // Update health from various messages
        if text.contains("‚ù§Ô∏è") || text.contains("üë§ –í–∏") || text.contains("–ó—ñ–ª–ª—è –ó–¥–æ—Ä–æ–≤'—è") {
            await gameState.updateHealth(text)
            
            // Report health restoration
            if text.contains("–∑–¥–æ—Ä–æ–≤'—è –ø–æ–≤–Ω—ñ—Å—Ç—é –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–æ") {
                await reportActionWithLevel(GameAction.healthRestored(), client: client, gameState: gameState)
            }
            
            // Report damage taken
            if let match = text.firstMatch(of: /\(-(\d+)\s*‚ù§Ô∏è\s*–∑–¥–æ—Ä–æ–≤'—è\)/) {
                let damage = Int(match.1) ?? 0
                var source = "unknown"
                if text.contains("üêù") {
                    source = "bee sting"
                }
                await reportActionWithLevel(GameAction.damageTaken(damage, source: source), client: client, gameState: gameState)
            }
            
            // Report potion use
            if text.contains("–ó—ñ–ª–ª—è –ó–¥–æ—Ä–æ–≤'—è") && text.contains("–í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–æ") {
                if let match = text.firstMatch(of: /–í—ñ–¥–Ω–æ–≤–ª–µ–Ω–æ\s*(\d+)\s*–∑–¥–æ—Ä–æ–≤'—è/) {
                    let amount = Int(match.1) ?? 0
                    let potionType = text.contains("–í–µ–ª–∏–∫–µ") ? "Large Health Potion" : "Health Potion"
                    await reportActionWithLevel(GameAction.usedItem(potionType, effect: "+\(amount) HP"), client: client, gameState: gameState)
                }
            }
        }
        
        // Update energy from various messages
        if text.contains("–µ–Ω–µ—Ä–≥—ñ") || text.contains("‚ö°") {
            await gameState.updateEnergy(text)
            
            // Report energy potion use
            if text.contains("–∑—ñ–ª–ª—è –µ–Ω–µ—Ä–≥—ñ—ó") && text.contains("–í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–æ") {
                if let match = text.firstMatch(of: /–í—ñ–¥–Ω–æ–≤–ª–µ–Ω–æ\s*(\d+)\s*–µ–Ω–µ—Ä–≥—ñ—ó/) {
                    let amount = Int(match.1) ?? 0
                    let potionType = text.contains("–ú–∞–ª–µ") ? "Small Energy Potion" : "Energy Potion"
                    await reportActionWithLevel(GameAction.usedItem(potionType, effect: "+\(amount) Energy"), client: client, gameState: gameState)
                }
            }
        }
        
        // Check for level up
        if text.contains("–†—ñ–≤–µ–Ω—å –ø—ñ–¥–≤–∏—â–µ–Ω–æ") {
            let oldLevel = await gameState.level
            await gameState.updateLevel(text)
            let newLevel = await gameState.level
            if oldLevel != newLevel {
                // Level up is important - always report
                await reportActionWithLevel(GameAction.levelUp(from: oldLevel, to: newLevel), client: client, gameState: gameState, isImportant: true)
            }
        }
        
        // Add human-like delay
        try? await Task.sleep(seconds: 1)
        
        // Check for energy shortage
        if text.contains("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ –µ–Ω–µ—Ä–≥—ñ—ó!") {
            // Extract wait time: "–ù–∞—Å—Ç—É–ø–Ω–µ –æ—á–∫–æ –≤—ñ–¥–Ω–æ–≤–∏—Ç—å—Å—è —á–µ—Ä–µ–∑ 4 —Ö–≤."
            if let match = text.firstMatch(of: /—á–µ—Ä–µ–∑\s*(\d+)\s*—Ö–≤/) {
                let minutes = Int(match.1) ?? 5
                await gameState.setEnergyWait(minutes: minutes)
                
                // Track state change
                let stateChange = await gameState.setPlayState(.waitingEnergy)
                if stateChange.changed {
                    await reportActionWithLevel(GameAction.stateChanged(from: stateChange.from.rawValue, to: stateChange.to.rawValue), client: client, gameState: gameState)
                }
                
                print("‚ö° No energy - waiting \(minutes) minutes...")
                await reportActionWithLevel(GameAction.noEnergy(minutes: minutes), client: client, gameState: gameState)
            }
            return
        }
        
        // Battle detection
        if text.contains("–ó'—è–≤–∏–≤—Å—è") && (text.contains("üêó") || text.contains("üêç") || 
           text.contains("üê∫") || text.contains("ü¶Ç") || text.contains("üêª") || text.contains("üì¶") ||
           text.contains("ü¶á") || text.contains("ü¶ú")) {
            await gameState.startBattle()
            
            // Track state change
            let stateChange = await gameState.setPlayState(.inBattle)
            if stateChange.changed {
                await reportActionWithLevel(GameAction.stateChanged(from: stateChange.from.rawValue, to: stateChange.to.rawValue), client: client, gameState: gameState)
            }
            
            // Extract enemy name
            var enemy = "Unknown enemy"
            if let match = text.firstMatch(of: /–ó'—è–≤–∏–≤—Å—è\s+(.+?)!/) {
                enemy = String(match.1)
            }
            
            print("‚öîÔ∏è Monster appeared - battle starting...")
            await reportActionWithLevel(GameAction.battleStarted(enemy), client: client, gameState: gameState)
            return
        }
        
        if text.contains("--- –†–∞—É–Ω–¥") {
            print("‚öîÔ∏è Battle in progress...")
            return
        }
        
        // Battle victory
        if text.contains("–í–∏ –æ—Ç—Ä–∏–º–∞–ª–∏:") && (text.contains("–∑–æ–ª–æ—Ç–∞") || text.contains("–¥–æ—Å–≤—ñ–¥—É")) {
            await gameState.endBattle()
            
            // Track state change
            let stateChange = await gameState.setPlayState(.exploring)
            if stateChange.changed {
                await reportActionWithLevel(GameAction.stateChanged(from: stateChange.from.rawValue, to: stateChange.to.rawValue), client: client, gameState: gameState)
            }
            
            // Extract rewards
            var gold = 0
            var exp = 0
            if let goldMatch = text.firstMatch(of: /üí∞\s*(\d+)\s*–∑–æ–ª–æ—Ç–∞/) {
                gold = Int(goldMatch.1) ?? 0
            }
            if let expMatch = text.firstMatch(of: /‚≠ê\s*(\d+)\s*–¥–æ—Å–≤—ñ–¥—É/) {
                exp = Int(expMatch.1) ?? 0
            }
            
            await gameState.updateBattleRewards(text)
            print("üèÜ Battle won!")
            // Battle victory is important - always report
            await reportActionWithLevel(GameAction.battleWon(gold: gold, exp: exp), client: client, gameState: gameState, isImportant: true)
            
            // Continue exploring if ready
            if await gameState.canExplore() {
                try? await Task.sleep(seconds: 2)
                await self.sendStaticInlineButton(client: client, chatId: chatId, text: "üó∫Ô∏è –î–æ—Å–ª—ñ–¥–∂—É–≤–∞—Ç–∏ (‚ö°1)")
            }
            return
        }
        
        // Exploration events - continue exploring
        if text.contains("üïØÔ∏è") || text.contains("üêù") || text.contains("üîç") || 
           text.contains("üìñ") || text.contains("üóø") || text.contains("ü§ù") || 
           text.contains("üó∫Ô∏è") || text.contains("üå∏") || text.contains("üê£") ||
           text.contains("üó∫Ô∏è") || text.contains("üìú") || text.contains("üó£Ô∏è") ||
           text.contains("üçÄ") || text.contains("üí∏") {
            print("üéØ Found something during exploration")
            
            // Extract event description
            var eventDesc = "exploration event"
            if text.contains("üå∏") {
                eventDesc = "mysterious garden"
            } else if text.contains("üïØÔ∏è") {
                eventDesc = "ancient altar"
            } else if text.contains("üóø") {
                eventDesc = "strange monument"
            } else if text.contains("üê£") {
                eventDesc = "mysterious footprints"
            } else if text.contains("üìú") {
                eventDesc = "ancient runes"
            } else if text.contains("üó£Ô∏è") {
                eventDesc = "cave echo"
            } else if text.contains("üçÄ") {
                eventDesc = "lucky coin"
            } else if text.contains("üí∏") {
                eventDesc = "meditation spot"
            }
            
            await reportActionWithLevel(GameAction.foundEvent(eventDesc), client: client, gameState: gameState)
            
            if await gameState.canExplore() {
                try? await Task.sleep(seconds: 1)
                await self.sendStaticInlineButton(client: client, chatId: chatId, text: "üó∫Ô∏è –î–æ—Å–ª—ñ–¥–∂—É–≤–∞—Ç–∏ (‚ö°1)")
            }
            return
        }
        
        // Greetings
        if text.contains("üëã") {
            if text.contains("–í–∏ –ø—Ä–∏–≤—ñ—Ç–∞–ª–∏") {
                // We greeted someone
                if let match = text.firstMatch(of: /–ø—Ä–∏–≤—ñ—Ç–∞–ª–∏\s+(.+?)!/) {
                    let player = String(match.1)
                    await reportActionWithLevel(GameAction.greeted(player), client: client, gameState: gameState)
                }
            } else if text.contains("–ø—Ä–∏–≤—ñ—Ç–∞–≤ –≤–∞—Å") {
                // Someone greeted us - just log it
                print("üëã Player greeting - ignoring")
            }
            return
        }
        
        // "Not in battle" message - ignore
        if text.contains("–í–∏ –Ω–µ –ø–µ—Ä–µ–±—É–≤–∞—î—Ç–µ –≤ –±–æ—é") {
            print("üôÖ Not in battle - ignoring")
            return
        }
        
        // Check for item findings
        if text.contains("üîç –í–∏ –∑–Ω–∞–π—à–ª–∏") {
            if let match = text.firstMatch(of: /–∑–Ω–∞–π—à–ª–∏\s+(.+?)!/) {
                let item = String(match.1)
                // Item findings are important - always report
                await reportActionWithLevel(GameAction.foundItem(item), client: client, gameState: gameState, isImportant: true)
            }
        }
        
        // Check for items found after battle
        if text.contains("–ó–Ω–∞–π–¥–µ–Ω—ñ –ø—Ä–µ–¥–º–µ—Ç–∏:") {
            let lines = text.split(separator: "\n")
            for line in lines {
                if !line.contains("–ó–Ω–∞–π–¥–µ–Ω—ñ") && !line.contains("–í–∏ –æ—Ç—Ä–∏–º–∞–ª–∏") && line.count > 3 {
                    // Item findings are important - always report
                    await reportActionWithLevel(GameAction.foundItem(String(line)), client: client, gameState: gameState, isImportant: true)
                }
            }
        }
        
        // Default: try to explore if no specific event
        let canExplore = await gameState.canExplore()
        if !text.contains("‚ùå") && !text.contains("---") {
            if canExplore {
                // Track state change to exploring
                let stateChange = await gameState.setPlayState(.exploring)
                if stateChange.changed {
                    await reportActionWithLevel(GameAction.stateChanged(from: stateChange.from.rawValue, to: stateChange.to.rawValue), client: client, gameState: gameState)
                }
                
                print("üó∫Ô∏è Continuing exploration...")
                await reportActionWithLevel(GameAction.explored(), client: client, gameState: gameState)
                await self.sendStaticInlineButton(client: client, chatId: chatId, text: "üó∫Ô∏è –î–æ—Å–ª—ñ–¥–∂—É–≤–∞—Ç–∏ (‚ö°1)")
            } else {
                // Check why we can't explore
                let health = await gameState.health
                let healthPercent = health.max > 0 ? Double(health.current) * 100 / Double(health.max) : 0
                if healthPercent < 90 {
                    // Track state change to waiting for health
                    let stateChange = await gameState.setPlayState(.waitingHealth)
                    if stateChange.changed {
                        await reportActionWithLevel(GameAction.stateChanged(from: stateChange.from.rawValue, to: stateChange.to.rawValue), client: client, gameState: gameState)
                    }
                    
                    print("üíî Health too low to explore")
                    await reportActionWithLevel(GameAction.lowHealth(), client: client, gameState: gameState)
                }
            }
        }
    }
}

// MARK: - Command Handler

extension OstromagBot {
    
    static func handleCommand(_ text: String, client: TDLibClient, chatId: Int64, gameState: GameState) async {
        let command = text.lowercased().trimmingCharacters(in: .whitespaces)
        
        switch command {
        case "/start":
            await gameState.startBot()
            print("üéÆ Bot started by command")
            await reportAction(GameAction.botStarted(session: "Manual"), client: client, gameState: gameState)
            
        case "/stop":
            await gameState.stopBot()
            print("üõë Bot stopped by command")
            await reportAction(GameAction.botStopped(), client: client, gameState: gameState)
            
        case "/log all":
            await gameState.setLogLevel(.all)
            await reportAction("üìù Logging level set to: ALL", client: client, gameState: gameState)
            
        case "/log important":
            await gameState.setLogLevel(.important)
            await reportAction("üìù Logging level set to: IMPORTANT only", client: client, gameState: gameState)
            
        case "/status":
            await reportAction(GameAction.initialStatus(), client: client, gameState: gameState)
            
        case "/help":
            let help = """
            ü§ñ Bot Commands:
            /start - Start bot automation
            /stop - Stop bot automation
            /status - Show current status
            /log all - Log all actions
            /log important - Log only important actions
            /help - Show this help
            """
            await sendMessage(client: client, chatId: gameState.reportingChat, text: help)
            
        default:
            if command.hasPrefix("/") {
                await sendMessage(client: client, chatId: gameState.reportingChat, text: "‚ö†Ô∏è Unknown command. Use /help for available commands.")
            }
        }
    }
}
